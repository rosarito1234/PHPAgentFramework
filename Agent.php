<?php

/**
 * Base Agent class for all agents in the system.
 * Each agent has a name, role, capabilities, tools, and internal memory.
 * Memory usage is important for optimizing LLM usage costs.
 */
class Agent {
    protected string $name;
    protected string $role;
    protected array $capabilities;
    protected array $tools;
    protected array $memory;
    protected string $model;
    protected string $apiKey;
    protected string $llmApiUrl;

    /**
     * Constructor for the Agent class.
     *
     * @param string $name         Name of the agent
     * @param string $role         Role or function (e.g., PM, Backend Dev)
     * @param array $capabilities  General skills the agent is able to perform
     * @param array $tools         Specific tools/actions the agent can use (i.e. writeFile)
     * @param string $model        Model to use for reasoning (e.g., gpt-3.5)
     * @param string $apiKey       API key for external LLM services
     * @param string $llmApiUrl    The API URL for the LLM you are going to use
     */
    public function __construct(string $name, string $role, array $capabilities, array $tools, string $model, string $apiKey, string $llmApiUrl) {
        $this->name = $name;
        $this->role = $role;
        $this->capabilities = $capabilities;
        $this->tools = $tools;
        $this->memory = [];
        $this->model = $model;
        $this->apiKey = $apiKey;
        $this->llmApiUrl = $llmApiUrl;
    }

    /**
     * Returns a list of capabilities the agent has.
     *
     * @return array
     */
    public function getCapabilities(): array {
        return $this->capabilities;
    }

    /**
     * Returns a list of tools the agent can use.
     *
     * @return array
     */
    public function getTools(): array {
        return $this->tools;
    }

    /**
     * Simulates the agent proposing a plan based on a given goal.
     *
     * @param string $goal
     * @return string Proposed plan
     */
    public function proposePlan(string $goal): string {
        // In a real system, this could query a language model
        // This is useful for debugging, and for keeping control of what each agent is doing.
        // If we use an orchestrator agent this will allow the orchestrator to better understand what is being done.
        return "To achieve the goal '{$goal}', I propose the following plan: [Step 1, Step 2, Step 3...]";
    }

    /**
     * Executes a given tool if available to the agent.
     *
     * @param string $toolName
     * @param array $params
     * @return mixed
     */
    public function executeTool(string $toolName, array $params) {
        if (!in_array($toolName, $this->tools)) {
            return "Tool '{$toolName}' is not available to this agent.";
        }

        // Placeholder for actual tool execution logic
        return "Executing tool '{$toolName}' with parameters: " . json_encode($params);
    }

    /**
     * Adds a message or result to the agent's memory.
     *
     * @param string $entry
     */
    public function addToMemory(string $entry): void {
        $this->memory[] = $entry;
    }

    /**
     * Returns the agent's memory log.
     *
     * @return array
     */
    public function getMemory(): array {
        return $this->memory;
    }

    /**
     * Summarizes memory entries for a specific recipient agent and goal using the LLM.
     *
     * @param string $recipientRole Role of the agent who will receive the memory (e.g., "Backend Dev")
     * @param string $goal Specific task or goal the recipient agent is working on
     * @return string Summary generated by the LLM
     */
    public function summarizeMemoryForLLM(string $recipientRole, string $goal): string {
        if (empty($this->memory)) {
            return "No relevant memory available.";
        }

        // Prepare the full memory as a block of text
        $memoryBlock = implode("\n", $this->memory);

        // Build the prompt for the LLM
        $prompt = <<<PROMPT
You are a coordination assistant helping agents work together on a technical project.

Based on the following memory:

$memoryBlock

Summarize only the information that would be useful for a $recipientRole who is about to work on the following goal:

"$goal"

Be concise and include any relevant technical decisions, design notes, or assumptions that should be passed on.
PROMPT;

        // Call the LLM and return the summary
        return $this->callLLM($prompt);
    }

        /**
     * Sends a prompt to the LLM (e.g., OpenAI) and returns the response text.
     * Logs the prompt and response for traceability.
     *
     * @param string $prompt The prompt to send
     * @return string LLM-generated response
     */
    protected function callLLM(string $prompt): string {
        $ch = curl_init($this->llmApiUrl);

        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_HTTPHEADER, [
            "Authorization: Bearer {$this->apiKey}",
            "Content-Type: application/json"
        ]);

        $postData = json_encode([
            "model" => $this->model,
            "messages" => [
                ["role" => "user", "content" => $prompt]
            ],
            "temperature" => 0.7
        ]);

        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);

        $startTime = microtime(true);
        $response = curl_exec($ch);
        $endTime = microtime(true);
        $duration = round($endTime - $startTime, 2);

        $result = json_decode($response, true);

        $usage = $result['usage'] ?? null;
        $tokenInfo = $usage ? [
            'prompt_tokens' => $usage['prompt_tokens'],
            'completion_tokens' => $usage['completion_tokens'],
            'total_tokens' => $usage['total_tokens']
        ] : 'not available';


        $reply = $result['choices'][0]['message']['content'] ?? "⚠️ LLM response unavailable.";

        // Log info
        $log = [
            "timestamp" => date('Y-m-d H:i:s'),
            "agent" => $this->name,
            "model" => $this->model,
            "duration" => "{$duration}s",
            "tokens" => $tokenInfo,
            "prompt" => $prompt,
            "response" => $reply
        ];

        $logText = json_encode($log, JSON_PRETTY_PRINT) . "\n\n";

        // Save to file (make sure "logs/" exists and is writable)
        file_put_contents(__DIR__ . "/logs/llm_calls.log", $logText, FILE_APPEND);

        return trim($reply);
    }




}
